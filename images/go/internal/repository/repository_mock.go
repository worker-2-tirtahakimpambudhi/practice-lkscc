package repository

import (
	"context"
	"github.com/stretchr/testify/mock"
	"github.com/tirtahakimpambudhi/restful_api/internal/entity"
	"github.com/tirtahakimpambudhi/restful_api/internal/model/request"
)

// UsersRepositoryMock is an autogenerated mock type for the UsersRepository type
type UsersRepositoryMock struct {
	mock.Mock
}

// Create provides a mock function with given fields: ctx, entity
func (m *UsersRepositoryMock) Create(ctx context.Context, entity *entity.Users) error {
	args := m.Called(ctx, entity)
	return args.Error(0)
}

// Update provides a mock function with given fields: ctx, entity, id
func (m *UsersRepositoryMock) Update(ctx context.Context, entity *entity.Users, id any) error {
	args := m.Called(ctx, entity, id)
	return args.Error(0)
}

// Delete provides a mock function with given fields: ctx, id
func (m *UsersRepositoryMock) Delete(ctx context.Context, id any) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

// CountById provides a mock function with given fields: ctx, id
func (m *UsersRepositoryMock) CountById(ctx context.Context, id any) (int64, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(int64), args.Error(1)
}

// Count provides a mock function with given fields: ctx
func (m *UsersRepositoryMock) Count(ctx context.Context) (int64, error) {
	args := m.Called(ctx)
	return args.Get(0).(int64), args.Error(1)
}

// ExistByKeyValue provides a mock function with given fields: ctx, keyvalue
func (m *UsersRepositoryMock) ExistByKeyValue(ctx context.Context, keyvalue map[string]any) (bool, error) {
	args := m.Called(ctx, keyvalue)
	return args.Bool(0), args.Error(1)
}

// GetById provides a mock function with given fields: ctx, entity, id
func (m *UsersRepositoryMock) GetById(ctx context.Context, entity *entity.Users, id any) error {
	args := m.Called(ctx, entity, id)
	if args.Get(0) == nil {
		return nil
	}
	return args.Error(0)
}

// GetByEmail provides a mock function with given fields: ctx, entity, email
func (m *UsersRepositoryMock) GetByEmail(ctx context.Context, entity *entity.Users, email string) error {
	args := m.Called(ctx, entity, email)
	if args.Get(0) == nil {
		return nil
	}
	return args.Error(0)
}

// GetAll provides a mock function with given fields: ctx, queryParams
func (m *UsersRepositoryMock) GetAll(ctx context.Context, queryParams *request.Page) ([]*entity.Users, error) {
	args := m.Called(ctx, queryParams)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*entity.Users), args.Error(1)
}

// Restore provides a mock function with given fields: ctx, id
func (m *UsersRepositoryMock) Restore(ctx context.Context, id any) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

// MockCacheRepository is an autogenerated mock type for the CacheRepository interface
type MockCacheRepository[T any] struct {
	mock.Mock
}

// GetFromCache provides a mock function with given fields: ctx, key
func (m *MockCacheRepository[T]) GetFromCache(ctx context.Context, key string) ([]T, error) {
	args := m.Called(ctx, key)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]T), args.Error(1)
}

// SetToCache provides a mock function with given fields: ctx, key, entities
func (m *MockCacheRepository[T]) SetToCache(ctx context.Context, key string, entities []T) error {
	args := m.Called(ctx, key, entities)
	return args.Error(0)
}

// DeleteToCacheByRegexKey provides a mock function with given fields: ctx, key
func (m *MockCacheRepository[T]) DeleteToCacheByRegexKey(ctx context.Context, key string) error {
	args := m.Called(ctx, key)
	return args.Error(0)
}

// DeleteToCache provides a mock function with given fields: ctx, key
func (m *MockCacheRepository[T]) DeleteToCache(ctx context.Context, key string) error {
	args := m.Called(ctx, key)
	return args.Error(0)
}
